import { EventInterface } from './event'
import { UserEnvelope, ContextEnvelope } from '../envelope'
import { UUID } from './uuid'
import { NotificationInterface } from './notification'

export type FlusherFunction = (record: Register) => Promise<void>

/**
 * Object injected by Booster in all command or event handlers to interact with the execution
 * context. By default, the events registered won't be stored until the handler has finished,
 * but you can force the storage by calling the `register.flush()` method.
 *
 * Example:
 * ```typescript
 *  public handle(register: Register): void {
 *    //...
 *    register.events(new CartItemChanged(cart, this.sku, this.quantity))
 *    if (this.hasPromotion()) {
 *      if (this.isEmpty()) {
 *        throw new Error("Added a promotion to an empty cart")
 *      } else {
 *        register.commands(new ApplyPromoToCart(this.promo, cart)
 *      }
 *    }
 *    // ...
 *  }
 * ```
 */
export class Register {
  public readonly eventList: Array<EventInterface | NotificationInterface> = []

  /**
   * Creates a new instance of Register
   *
   * @param {UUID} requestID - The ID of the current request
   * @param {Record<string, string>} responseHeaders - The response headers object. It can be changed by the user.
   * @param {FlusherFunction} flusher - The provider-dependent function used to flush the events to the event store.
   * @param {UserEnvelope} [currentUser] - The current user envelope, if available
   * @param {ContextEnvelope} [context] - The current context envelope, if available
   */
  public constructor(
    /** Unique request identifier. This identifier is propagated automatically by Booster
     * to all the events generated during a request, as well as all subsequent events
     * generated by event handlers. This identifier can be used as a correlation
     * identifier to build the event tree coming from a single request. */
    readonly requestID: UUID,
    /** In the context of a command handler, the `responseHeaders` object contains the headers
     * that will be returned to the client in the response. You can use this object to set
     * custom headers or alter the default ones. */
    readonly responseHeaders: Record<string, string>,
    /** Private flusher function that will be called when the flush method is called. This property
     * is reserved to be used internally by Booster. */
    private flusher: FlusherFunction,
    /** Object that references the current user. This property is initialized by Booster in a command,
     * and in the same way as the `requestID` property, it is propagated to all the events generated
     * afterwards. */
    readonly currentUser?: UserEnvelope,
    /** In the context of a command handler, the `context` object contains the context of the request. */
    readonly context?: ContextEnvelope
  ) {}

  /**
   * Register a list of events to be added to the event-store on handler completion
   *
   * @param {...Array<EventInterface|NotificationInterface>} events - The events to register
   * @returns {Register} The current Register instance, so the calls to events and/or flush can be chained.
   */
  public events(...events: Array<EventInterface | NotificationInterface>): Register {
    this.eventList.push(...events)
    return this
  }

  /**
   * Flushes the accumulated events and commands to the event store using the provider-depdent flusher function.
   * This method can be called from a command or event handler to force the persistion of the events
   * to the event store. After the events have been flushed, the eventList is cleared, so the same
   * register instance can be used to register more events.
   *
   * @returns {Promise<void>} A Promise that resolves when the flush operation is complete
   */
  public async flush(): Promise<void> {
    await this.flusher(this)
    this.eventList.length = 0
  }
}
